https://github.com/gotalab/claude-code-spec


https://github.com/abagames/slash-criticalthink

これって書くべき？　チームでCLAUDE.mdや.cursor/rulesを育てる
https://zenn.dev/appbrew/articles/7eb12fff5738f4

kiroを参考にして作成したCLAUDE.md
https://izanami.dev/post/11c5067c-d2f9-4945-8944-0d1c20c1263d

壁打ちプロンプト(rubber-ducking.md)
https://x.com/tamaki_8128/status/1996049449899168143?s=20

副業の青色申告の流れをアイソメトリックなピクト図解して
https://x.com/yugen_matuni/status/1996759831622107366?s=20

フローチャート
https://x.com/tegnike/status/1995994601279422532?s=20

playwrite skills
https://github.com/lackeyjb/playwright-skill


## skills作成のベストプラクティス
リンク:
- https://x.com/suna_gaku/status/2004130495450567034?s=20
- https://t.co/OPSzbidXm1

### 内容
Anthropic が出している 「Skills 作成のベストプラクティス」 かなり勉強になりました...
改めて内容を整理したので、シェアします！

【コア原則】
簡潔さが鍵
スキルは、会話履歴などともコンテキストを共有するため、簡潔に書くのが重要になる。
そのため、 「Claude がすでに知っていることは書かない」 ことが重要になる。

SKills に追記するべきかどうかを判断する三つの問いかけ
- 「Claudeは本当にこの説明が必要ですか？」
-「Claudeがこれを知っていると仮定できますか？」
- 「このパラグラフはそのトークンコストに見合う価値がありますか？」

適切な自由度の設定 をする
タスクの 「脆弱性」 と 「可変性」に合わせて、指示の具体性を決める。
- 複数アプローチが有効な場合（例：コードレビュー）は、自由度を高くして 「一般的な方向を示す」 程度にする
- 一つのアプローチしかなく、ミスしやすい場合 (データベースマイグレーション) は、具体的なガードレールと正確な指示を伝える

全モデルでテストする
- Haikuでは十分なガイダンスがあるか
- Sonnetでは明確で効率的か
- Opusでは過度な説明を避けているか
複数のモデルでスキルを使用する予定があるなら、これを確認する。

【スキル構造】
YAMLフロントマター
- nameは最大64文字で小文字・数字・ハイフンのみ
- descriptionは最大1024文字で空不可

命名規則
一貫した命名パターンを使用する。また、スキル名には 「動名詞形 (動詞 + -ing)」 を使用する。
nameフィールドは小文字、数字、ハイフンのみを使用する必要がある。
良い例はprocessing-pdfs、analyzing-spreadsheets、managing-databases。避けるべきはhelper、documents、anthropic-helperなどの 「曖昧な名前」・「過度に一般的」・「予約語」など。

効果的な説明を書く
常に三人称で書き、具体的で主要な用語を含める。
つまり、「何をするか」と「いつ使用するか」の 「特定のトリガー/コンテキストの両方」 を含める。
いい例 (PDF処理スキル)： description: PDFファイルからテキストと表を抽出し、フォームに入力し、ドキュメントをマージします。PDFファイル、フォーム、またはドキュメント抽出について言及している場合に使用してください。

段階的開示パターン
SKILL. mdは目次として機能させて、詳細は別ファイルに配置していく。

SKILL. md作成時の注意点
- SKILL. mdボディを最適なパフォーマンスのために500行以下に保つ
- この制限に近づいたときにコンテンツを別のファイルに分割する
- ３つパターンを使用して、指示、コード、リソースを効果的に整理する

SKILL .mdの構成パターン
1. 参照付き高レベルガイド
SKILL. mdにメインの指示を置き、詳細は別ファイルへリンク。
2. メイン固有の組織
ドメイン別にコンテンツを整理し、無関連なコンテキストのロードを回避する。
3. 条件付き詳細
基本コンテンツを表示し、高度なコンテンツにリンクする。

深くネストされた参照を避ける
SKILL. mdから1レベル深いまでにしておく。
すべての参照ファイルはSKILL. mdから直接リンクして、必要に応じてClaudeが完全なファイルを読むようにする。
100行以上の参照ファイルの場合、上部に目次を含めて、部分的な読み取りでも、利用可能な情報を全て与えられるようにする。

【ワークフローとフィードバックループ】
複雑なタスクにはワークフローを利用する
複雑な操作を明確で順序立ったステップに分割する。この時に  「チェックリストを提供してClaudeが進行状況を追跡できる」 ようにする。
これにより、重要な検証をスキップするのを防げる。

フィードバックループを実装する
「バリデータを実行 → エラーを修正 → 繰り返す」 を行なう。これにより、出力品質を改善できる。

【コンテンツガイドライン】
- 時間に敏感な情報を避け、いつ古くなるかわからない情報を含めない
- 一貫した用語を使用する

一般的なパターン
合計 3種類

テンプレートパターン
- 厳密な要件には「常にこの正確なテンプレート構造を使用してください」などと記載されたテンプレート
- 柔軟なガイダンスには「これは合理的なデフォルト形式ですが、分析に基づいて最善の判断を使用してください」などと記載されたテンプレート

例パターン
出力品質が例を見ることに依存するスキルの場合、入出力ペアを提供する。例えば 「これらの例に従ってコミットメッセージを生成してください」 など

条件付きワークフローパターン
決定ポイントを通じてClaudeをガイドする。
「新規作成なら作成ワークフロー」「既存編集なら編集ワークフロー」のように分岐させる

ワークフローが長くなりすぎたら、別ファイルに移動した上で、「タスクに基づいて適切なファイルを読む」 ように指示する。

【評価と反復】
最初に評価を構築する
広範なドキュメントを作成する前に評価を作成する。これにより、実際の問題を解決することを確認できる。

評価駆動開発
1. ギャップを特定する
スキルなしで代表的なタスクでClaudeを実行し、具体的な失敗または欠落しているコンテキストを文書化する
2. 評価を作成する
これらのギャップをテストする3つのシナリオを構築する
3. ベースラインを確立する
スキルなしでClaudeのパフォーマンスを測定する
4. 最小限の指示を書く
ギャップに対処して評価に合格するのに十分なコンテンツのみを作成する
5. 反復する
評価を実行し、ベースラインと比較し、改善する

Anthropic は、まだスキルが正しく動くかテストするツールは作っていないので、自分でテストする必要がある。

Claudeを使用してスキルを反復的に開発する
Claude A（専門家）がスキル設計を支援し、Claude B（エージェント）が実際のタスクでテストする。

新しいスキルの作成
1. スキルなしでタスクを完了する
通常のプロンプトを使用して問題を解決し、その中で知識を共有していく。
2. 再利用可能なパターンを特定する
タスク完了後、使用したコンテキストを特定する。
3. Claude Aにスキルを作成するよう依頼する
「2. 」の作業のSkills を作成してください。この時に OO のルールを含めてください、のような形。
4. 簡潔性をレビューする
Claude Aが不要な説明を追加していないかチェックする。
5. 情報アーキテクチャを改善する
Claude Aにコンテンツをより効果的に整理するよう依頼する。
6. 同様のタスクでテストする
Claude B（スキルがロードされた新しいインスタンス）で関連するユースケースでスキルを使用して、正しく動くか観察する。
7. 観察に基づいて反復する
Claude Bが苦労したり何かを逃したりした場合、具体的な情報を持ってClaudeAに戻り、追加・修正するべき内容を尋ねる。

既存のスキルを反復(改善)する
作成と同じプロセスを行う。
- Claude Aと協力する
- Claude Bでテストする
- Claude Bの動作を観察する
具体的な手順
1. 実際のワークフローでスキルを使用する
2. Claude Bの動作を観察する
3. 改善のためにClaudeAに戻る
4. Claude Aの提案をレビューする
5. 変更を適用してテストする
6. 使用に基づいて繰り返す

チームフィードバックの収集
1. スキルをチームメイトと共有し、使用を観察する
2. 「スキルは予期したときにアクティブになりますか？指示は明確ですか？何が不足していますか？」を 尋ねる
3. フィードバックを組み込んで、独自の使用パターンの盲点に対処する

Claudeがスキルをナビゲートする方法を観察する
Claudeが実際に使用する方法に注意を払う。

注意すること
- 予期しない探索パス (予期しない順序でファイルを読んでいないか？)
- 接続の欠落 (重要なファイルへの参照に従うのに失敗してないか？)
- 特定のセクションへの過度な依存 (Claudeが繰り返し同じファイルを読む場合、http://SKILL.mdの代わりに配置するべきかも？)
- 無視されたコンテンツ (ファイルにアクセスしない場合、 「不要」 か 「指示が不十分」 のどちらか)
上記の観察に基づいて反復する。
また、「name」と「description」は特に重要なので、 「何をするか、いつ使用すべきか」 が明確に書かれているか？ に注意する。

【避けるべきアンチパターン】
Windowsスタイルのパスを避ける

多くのオプションを提供しすぎることを避ける
必要でない限り、複数のアプローチを提示しない。デフォルトを提供する。

高度：実行可能なコード付きスキル
解決する、逃げ出さない

エラー条件をスクリプト内で処理する
エラーが起きても、デフォルトの処理を用意したり、代替手段を提供して、処理を継続できるようにする。
構成パラメータも正当化されて、文章化する。
REQUEST_TIMEOUT = 30」で「通常30秒以内に完了するから」などのコメントをつけ、マジックナンバーを避ける。

ユーティリティスクリプトを提供する
ユーティリティスクリプトの利点
- 生成されたコードより信頼性が高い
- トークンを節約できる（コンテキストにコードを含める必要がない）
- 時間を節約できる（コード生成は不要）
- 使用全体で一貫性を確保できる

スキルにスクリプトを含める時は、Claudeに「実行させる」か「読ませる」かを明確にする。
基本的には、実行が推奨される。

ビジュアル分析を使用する
入力を画像としてレンダリングできる場合、Claudeに分析させることができる。

検証可能な中間出力を作成する
複雑でオープンエンドのタスクを実行する場合、間違いを防止するために、途中で確認できる中間ファイルを作らせる。

「計画-検証-実行」パターン
最初に構造化形式で計画を作成し、その計画を実行する前にスクリプトで検証することで、早期にエラーをキャッチする。

なぜ このパターンが機能するか？
- 早期にエラーをキャッチできる
検証は変更を適用する前に問題を見つけられる。
- 機械検証可能
スクリプトは客観的な検証を提供してくれる。
- 可逆的な計画
Claudeは元のファイルに触れずに計画を反復できる。
- 明確なデバッグ
エラーメッセージは特定の問題を指す。
このパターンは、バッチ操作、破壊的な変更、複雑な検証ルール、高リスク操作 で利用できます！

実装のヒント
「フィールド'signature_date'が見つかりません。利用可能なフィールド：customer_name、order_total、signature_date_signed」のような、 「特定のエラーメッセージ」 を使用して検証スクリプトを詳細にする。

パッケージ依存関係
コード実行環境で実行され、プラットフォーム固有の制限がある。
- claude. ai
npmとPyPiからパッケージをインストールでき、GitHubリポジトリからプルできる
- Anthropic API
ネットワークアクセスがなく、ランタイムパッケージのインストールがない。
必要なパッケージが、コード実行ツールドキュメントで利用可能であることを確認する。

Claudeがスキルにアクセスする方法
1. メタデータ事前ロード
2. オンデマンドでファイルを読む
3. スクリプトを効率的に実行
4. 大きなファイルのコンテキストペナルティなし

スキルのファイル・フォルダをどう整理すべきか
ファイルパスが重要
- Claudeはファイルシステムのようにスキルディレクトリをナビゲートする
フォワードスラッシュ（reference/guide.md）を使用し、バックスラッシュは使用しない。

- ファイルに説明的な名前を付ける
コンテンツを示す名前を使用する。doc2. mdではなく、「form_validation_rules. md」 を使用する。

- 発見のために整理する
ドメインまたは機能別にディレクトリを構造化する。
  - 良い例 : reference/finance.md、reference/sales.md
  - 悪い例 : docs/file1.md、docs/file2.md

- 包括的なリソースをバンドルする
完全なAPIドキュメント、広範な例、大規模なデータセットを含められる。アクセスされるまでコンテキストペナルティはない。

- 決定論的操作にはスクリプトを優先する
コード生成を求めず、validate_form.pyを作成する

- 実行意図を明確にする
  - 「analyze_form.pyを実行してフィールドを抽出する」（実行）
  - 「抽出アルゴリズムについてはanalyze_form.pyを参照してください」（参照として読む）

- ファイルアクセスパターンをテストする
実際のリクエストでテストして、ディレクトリ構造をナビゲートできることを確認する。

【MCPツール参照】
常に完全修飾ツール名を使用する。
- 形式：ServerName:tool_name
- 例：BigQuery:bigquery_schemaツールを使用してテーブルスキーマを取得します。

ツールがインストールされていると仮定しない
依存関係について明示する。「必要なパッケージをインストールし、その後に利用してください」という指示を入れる。

【技術的な注記】
YAMLフロントマター要件
SKILL. mdフロントマターには、特定の検証ルールを持つnameとdescriptionフィールドが必要
- name：最大64文字、小文字/数字/ハイフンのみ、XMLタグなし、予約語なし
- description：最大1024文字、空でない、XMLタグなし

トークン予算
SKILL. mdボディを500行以下に保つ。これを超える場合は、段階的開示パターンを使用して別のファイルに分割する。

【効果的なスキルのチェックリスト】
コア品質
- 説明は具体的で主要な用語を含む
- 説明にはスキルが何をするか、いつ使用するかが含まれる
- SKILL. mdボディは500行以下
- 追加の詳細は別のファイルにある（必要な場合）
- 時間に敏感な情報がない（または「古いパターン」セクションにある）
- 全体で一貫した用語
- 例は抽象的ではなく具体的
- ファイル参照は1レベルだけ
- 段階的開示が適切に使用されている
- ワークフローに明確なステップがある

コードとスクリプト
- スクリプトは問題を解決し、Claudeに任せない
- エラー処理は明示的で有用
- 「ブードゥー定数」がない（すべての値が正当化されている）
- 必要なパッケージが指示にリストされ、利用可能であることが確認されている
- スクリプトに明確なドキュメントがある
- Windowsスタイルのパスがない（すべてフォワードスラッシュ）
- 重要な操作の検証/確認ステップ
- 品質が重要なタスクに含まれるフィードバックループ

テスト
- 少なくとも3つの評価が作成されている
- Haiku、Sonnet、Opusでテストされている
- 実際の使用シナリオでテストされている
- チームフィードバックが組み込まれている（該当する場合）
